import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Grid2x2, LayoutList, Menu, Plus, Save, Sparkles, Trash2 } from "lucide-react";
import { cn } from "@/lib/utils";
import { renderMarkdownToCards, PRESETS } from "@/lib/renderer";
import * as storage from "@/lib/storage";
import { exportCardsToPng } from "@/lib/exporter";

const PREVIEW_SCALE_DEFAULT = 0.305;
const PREVIEW_SCALE_COLLAPSED = 0.545;
const SIDEBAR_STATE_KEY = "instaCard.sidebarCollapsed";
const FIRST_VISIT_KEY = "instaCard.firstVisitDone";
const MD_DATA_IMAGE_RE = /!\[([^\]]*)\]\(\s*(data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+)\s*\)/g;
const MD_INLINE_REF_RE = /!\[([^\]]*)\]\(\s*(cid:img-\d+)\s*\)/g;
const RATIO_OPTIONS = ["4:5", "1:1", "3:4", "4:3"];
const DEFAULT_STYLE_TABS = ["reference", "modern", "minimal"];

const EXAMPLE_MARKDOWN = `---

# ğŸ“¸ Insta Card Maker ì‚¬ìš©ë²•

ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ê¸€ì„ ì“°ë©´ ìë™ìœ¼ë¡œ ì¹´ë“œë‰´ìŠ¤ê°€ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤.

ì§€ê¸ˆ ë³´ê³  ìˆëŠ” ì´ ì¹´ë“œê°€ ë°”ë¡œ ì˜ˆì‹œì…ë‹ˆë‹¤.

---

# âœï¸ ê¸°ë³¸ ì‘ì„±ë²•

**ì œëª©**ì€ \`# ì œëª©\`ìœ¼ë¡œ ì‘ì„±í•©ë‹ˆë‹¤.

**êµµì€ ê¸€ì”¨**ëŠ” \`**í…ìŠ¤íŠ¸**\`ë¡œ ê°ì‹¸ì„¸ìš”.

ì¤„ë°”ê¿ˆì€ ë¹ˆ ì¤„ í•˜ë‚˜ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤.

---

# âœ‚ï¸ ìŠ¬ë¼ì´ë“œ ë‚˜ëˆ„ê¸°

ì¹´ë“œë¥¼ ë‚˜ëˆ„ë ¤ë©´ \`---\` êµ¬ë¶„ì„ ì„ ì‚¬ìš©í•˜ì„¸ìš”.

êµ¬ë¶„ì„  ìœ„ì•„ë˜ë¡œ ë¹ˆ ì¤„ì„ ë„£ìœ¼ë©´ ë©ë‹ˆë‹¤.

ì´ë ‡ê²Œ í•˜ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì¹´ë“œë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.

---
<!-- bg-image: https://images.unsplash.com/photo-1506744038136-46273834b3fb?w=1080&q=80 -->

# ğŸ–¼ï¸ ë°°ê²½ ì´ë¯¸ì§€ ë„£ê¸°

ì´ ì¹´ë“œì—ëŠ” ë°°ê²½ ì´ë¯¸ì§€ê°€ ì ìš©ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

ìŠ¬ë¼ì´ë“œ ìƒë‹¨ì— bg-image ë””ë ‰í‹°ë¸Œë¥¼ ë„£ìœ¼ë©´ í•´ë‹¹ ì¹´ë“œì—ë§Œ ë°°ê²½ì´ ì ìš©ë©ë‹ˆë‹¤.

í˜•ì‹: &lt;!-- bg-image: ì´ë¯¸ì§€URL --&gt;

---

# ğŸ“‹ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸°

í´ë¦½ë³´ë“œì— ë³µì‚¬í•œ ì´ë¯¸ì§€ë¥¼ ì—ë””í„°ì— ë°”ë¡œ **Ctrl+V** (Mac: **Cmd+V**)ë¡œ ë¶™ì—¬ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì›¹ì—ì„œ ì´ë¯¸ì§€ë¥¼ ë³µì‚¬í•˜ê±°ë‚˜ ìŠ¤í¬ë¦°ìƒ·ì„ ì°ì€ ë’¤ ë°”ë¡œ ë¶™ì—¬ë„£ì–´ ë³´ì„¸ìš”.

---

# ğŸ¨ ìŠ¤íƒ€ì¼ & ë¹„ìœ¨

ìƒë‹¨ **Styles** íƒ­ì—ì„œ ë””ìì¸ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜¤ë¥¸ìª½ ìƒë‹¨ì—ì„œ **ë¹„ìœ¨**(4:5, 1:1 ë“±)ë„ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

# ğŸ’¾ ì €ì¥ & ë‚´ë³´ë‚´ê¸°

- **Save** ë²„íŠ¼ìœ¼ë¡œ ë¸Œë¼ìš°ì €ì— ì €ì¥
- **Export** ë²„íŠ¼ìœ¼ë¡œ PNG ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
- **Library**ì—ì„œ ì €ì¥ëœ ê¸€ ê´€ë¦¬

---
<!-- bg-image: https://images.unsplash.com/photo-1519681393784-d120267933ba?w=1080&q=80 -->

# ğŸš€ ì§€ê¸ˆ ì‹œì‘í•´ë³´ì„¸ìš”!

ì™¼ìª½ ì—ë””í„°ì˜ ë‚´ìš©ì„ ì§€ìš°ê³  ììœ ë¡­ê²Œ ì‘ì„±í•´ë³´ì„¸ìš”.

**New Slide** ë²„íŠ¼ì„ ëˆŒëŸ¬ ìƒˆ ê¸€ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¦ê±°ìš´ ì¹´ë“œë‰´ìŠ¤ ë§Œë“¤ê¸° ë˜ì„¸ìš”! ğŸ‰`;

function formatPresetLabel(name) {
  return String(name || "")
    .split("-")
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function formatDate(isoText) {
  const date = new Date(isoText);
  if (Number.isNaN(date.getTime())) return "";
  return date.toLocaleString("ko-KR", {
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

function formatRelative(isoText) {
  const date = new Date(isoText);
  const time = date.getTime();
  if (Number.isNaN(time)) return "Updated recently";

  const delta = Date.now() - time;
  const minute = 60 * 1000;
  const hour = 60 * minute;
  const day = 24 * hour;

  if (delta < hour) {
    const mins = Math.max(1, Math.floor(delta / minute));
    return `Updated ${mins}m ago`;
  }
  if (delta < day) {
    const hours = Math.max(1, Math.floor(delta / hour));
    return `Updated ${hours}h ago`;
  }
  if (delta < 2 * day) return "Updated Yesterday";
  return `Updated ${formatDate(isoText)}`;
}

function getInitialSidebarState() {
  try {
    return localStorage.getItem(SIDEBAR_STATE_KEY) === "1";
  } catch (_err) {
    return false;
  }
}

export default function App() {
  const [presets, setPresets] = useState([]);
  const [savedPosts, setSavedPosts] = useState([]);
  const [currentPostId, setCurrentPostId] = useState(null);
  const [postTitle, setPostTitle] = useState("");
  const [markdown, setMarkdown] = useState("");
  const [preset, setPreset] = useState("reference");
  const [ratio, setRatio] = useState("4:5");
  const [bgImage, setBgImage] = useState("");
  const [sidebarCollapsed, setSidebarCollapsed] = useState(getInitialSidebarState);
  const [status, setStatus] = useState({ message: "", isError: false });
  const [previewState, setPreviewState] = useState({
    loading: false,
    error: "",
    width: 1080,
    height: 1350,
  });
  const [previewFrames, setPreviewFrames] = useState([]);

  const statusTimerRef = useRef(null);
  const inlineImageSeqRef = useRef(0);
  const inlineImagesRef = useRef(new Map());
  const renderRequestRef = useRef(0);
  const activePreviewUrlsRef = useRef([]);
  const markdownRef = useRef(null);

  const previewScale = sidebarCollapsed ? PREVIEW_SCALE_COLLAPSED : PREVIEW_SCALE_DEFAULT;
  const scaledW = useMemo(() => Math.round(previewState.width * previewScale), [previewScale, previewState.width]);
  const scaledH = useMemo(() => Math.round(previewState.height * previewScale), [previewScale, previewState.height]);

  const styleTabs = useMemo(() => {
    const names = presets.map((item) => item.name).filter(Boolean);
    const source = names.length ? names : DEFAULT_STYLE_TABS;
    return source.map((value) => ({
      value,
      label: formatPresetLabel(value),
    }));
  }, [presets]);

  const clearPreviewUrls = useCallback((urls) => {
    const targetUrls = urls || activePreviewUrlsRef.current;
    targetUrls.forEach((url) => URL.revokeObjectURL(url));
    if (!urls) activePreviewUrlsRef.current = [];
  }, []);

  const showStatus = useCallback((message, isError = false) => {
    setStatus({ message: String(message || ""), isError });
    if (!message) return;
    clearTimeout(statusTimerRef.current);
    statusTimerRef.current = setTimeout(() => {
      setStatus((prev) => (prev.message === message ? { message: "", isError: false } : prev));
    }, 2400);
  }, []);

  const makeInlineImageRef = useCallback((dataUrl) => {
    inlineImageSeqRef.current += 1;
    const ref = `cid:img-${inlineImageSeqRef.current}`;
    inlineImagesRef.current.set(ref, dataUrl);
    return ref;
  }, []);

  const expandInlineImageRefs = useCallback((md) => {
    return String(md || "").replace(MD_INLINE_REF_RE, (match, alt, ref) => {
      const dataUrl = inlineImagesRef.current.get(ref);
      if (!dataUrl) return match;
      return `![${alt || "image"}](${dataUrl})`;
    });
  }, []);

  const compactDataImageRefs = useCallback(
    (md) =>
      String(md || "").replace(MD_DATA_IMAGE_RE, (_match, alt, dataUrl) => {
        const ref = makeInlineImageRef(dataUrl);
        return `![${alt || "image"}](${ref})`;
      }),
    [makeInlineImageRef]
  );

  const loadPresets = useCallback(() => {
    const list = Object.entries(PRESETS).map(([name, p]) => ({
      name,
      description: p.description,
      titleColor: p.titleColor,
      bgColor: p.bgColor,
    }));
    setPresets(list);
    setPreset((current) => {
      if (list.some((item) => item.name === current)) return current;
      if (list.some((item) => item.name === "reference")) return "reference";
      return list[0]?.name || current;
    });
  }, []);

  const loadPostList = useCallback(() => {
    setSavedPosts(storage.listPosts());
  }, []);

  const loadPost = useCallback(
    (postId) => {
      const data = storage.getPost(postId);
      if (!data) { showStatus("ê²Œì‹œë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", true); return; }

      setCurrentPostId(data.id);
      setPostTitle(data.title || "");
      setMarkdown(compactDataImageRefs(String(data.markdown || "")));
      setPreset(data.preset || "reference");
      setRatio(data.ratio || "4:5");
      setBgImage(data.backgroundImage || "");
      showStatus("ê²Œì‹œë¬¼ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.");
    },
    [compactDataImageRefs, showStatus]
  );

  const resetToNewPost = useCallback(() => {
    setCurrentPostId(null);
    setPostTitle("");
    setMarkdown("");
    setBgImage("");
    showStatus("ìƒˆ ê²Œì‹œë¬¼ ì‘ì„± ëª¨ë“œ");
  }, [showStatus]);

  const renderPreview = useCallback(() => {
    const currentMarkdown = markdown.trim();
    if (!currentMarkdown) {
      clearPreviewUrls();
      setPreviewFrames([]);
      setPreviewState({ loading: false, error: "", width: 1080, height: 1350 });
      return;
    }

    const requestId = renderRequestRef.current + 1;
    renderRequestRef.current = requestId;
    setPreviewState((prev) => ({ ...prev, loading: true, error: "" }));

    try {
      const data = renderMarkdownToCards(expandInlineImageRefs(markdown), {
        preset,
        ratio,
        backgroundImage: bgImage.trim() || undefined,
      });

      if (renderRequestRef.current !== requestId) return;

      const cards = Array.isArray(data.cards) ? data.cards : [];
      if (!cards.length) {
        clearPreviewUrls();
        setPreviewFrames([]);
        setPreviewState({ loading: false, error: "", width: data.width || 1080, height: data.height || 1350 });
        return;
      }

      const frames = cards.map((html, index) => {
        const blob = new Blob([html], { type: "text/html" });
        const url = URL.createObjectURL(blob);
        return {
          key: `${requestId}-${index}`,
          index: index + 1,
          total: cards.length,
          url,
        };
      });

      clearPreviewUrls();
      activePreviewUrlsRef.current = frames.map((frame) => frame.url);
      setPreviewFrames(frames);
      setPreviewState({
        loading: false,
        error: "",
        width: data.width || 1080,
        height: data.height || 1350,
      });
    } catch (err) {
      if (renderRequestRef.current !== requestId) return;
      clearPreviewUrls();
      setPreviewFrames([]);
      setPreviewState({ loading: false, error: err.message, width: 1080, height: 1350 });
    }
  }, [bgImage, clearPreviewUrls, expandInlineImageRefs, markdown, preset, ratio]);

  const savePost = useCallback(() => {
    const payload = {
      title: postTitle.trim(),
      markdown: expandInlineImageRefs(markdown),
      preset,
      ratio,
      backgroundImage: bgImage.trim(),
    };

    if (!payload.markdown.trim()) {
      showStatus("ë³¸ë¬¸(markdown)ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”.", true);
      return;
    }

    const isUpdate = Boolean(currentPostId);
    let data;
    if (isUpdate) {
      data = storage.updatePost(currentPostId, payload);
      if (!data) { showStatus("ê²Œì‹œë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", true); return; }
    } else {
      data = storage.createPost(payload);
    }

    setCurrentPostId(data.id);
    if (data.title) setPostTitle(data.title);
    loadPostList();
    showStatus(isUpdate ? "ê²Œì‹œë¬¼ì„ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤." : "ê²Œì‹œë¬¼ì„ ì €ì¥í–ˆìŠµë‹ˆë‹¤.");
  }, [bgImage, currentPostId, expandInlineImageRefs, loadPostList, markdown, postTitle, preset, ratio, showStatus]);

  const deletePost = useCallback(() => {
    if (!currentPostId) return;
    if (!window.confirm("í˜„ì¬ ê²Œì‹œë¬¼ì„ ì‚­ì œí• ê¹Œìš”?")) return;

    const ok = storage.deletePost(currentPostId);
    if (!ok) { showStatus("ê²Œì‹œë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", true); return; }

    setCurrentPostId(null);
    setPostTitle("");
    setMarkdown("");
    setBgImage("");
    loadPostList();
    showStatus("ê²Œì‹œë¬¼ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.");
  }, [currentPostId, loadPostList, showStatus]);

  const [exporting, setExporting] = useState(false);

  const exportCards = useCallback(async () => {
    const md = expandInlineImageRefs(markdown).trim();
    if (!md) {
      showStatus("ë‚´ë³´ë‚¼ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.", true);
      return;
    }
    try {
      setExporting(true);
      const data = renderMarkdownToCards(md, {
        preset,
        ratio,
        backgroundImage: bgImage.trim() || undefined,
      });
      if (!data.cards.length) {
        showStatus("ìƒì„±ëœ ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.", true);
        return;
      }
      showStatus(`PNG ë‚´ë³´ë‚´ê¸° ì¤‘... (0/${data.cards.length})`);
      await exportCardsToPng(data.cards, data.width, data.height, ({ current, total }) => {
        showStatus(`PNG ë‚´ë³´ë‚´ê¸° ì¤‘... (${current}/${total})`);
      });
      showStatus(`${data.cards.length}ì¥ì˜ ì¹´ë“œë¥¼ ë‚´ë³´ëƒˆìŠµë‹ˆë‹¤.`);
    } catch (err) {
      showStatus(`ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ${err.message}`, true);
    } finally {
      setExporting(false);
    }
  }, [bgImage, expandInlineImageRefs, markdown, preset, ratio, showStatus]);

  const insertAtCursor = useCallback((text, start, end) => {
    setMarkdown((prev) => `${prev.slice(0, start)}${text}${prev.slice(end)}`);
    requestAnimationFrame(() => {
      const nextCursor = start + text.length;
      if (markdownRef.current) {
        markdownRef.current.selectionStart = nextCursor;
        markdownRef.current.selectionEnd = nextCursor;
        markdownRef.current.focus();
      }
    });
  }, []);

  const handlePaste = useCallback(
    (event) => {
      const items = event.clipboardData?.items;
      if (items) {
        for (const item of items) {
          if (!item.type.startsWith("image/")) continue;
          event.preventDefault();
          const file = item.getAsFile();
          if (!file) return;
          const target = event.target;
          const start = target.selectionStart;
          const end = target.selectionEnd;
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = String(reader.result || "");
            const ref = makeInlineImageRef(dataUrl);
            insertAtCursor(`![image](${ref})`, start, end);
          };
          reader.readAsDataURL(file);
          return;
        }
      }

      const pastedText = event.clipboardData?.getData("text") || "";
      if (!pastedText.includes("data:image/")) return;
      event.preventDefault();
      const target = event.target;
      const start = target.selectionStart;
      const end = target.selectionEnd;
      insertAtCursor(compactDataImageRefs(pastedText), start, end);
    },
    [compactDataImageRefs, insertAtCursor, makeInlineImageRef]
  );

  useEffect(() => {
    const timer = setTimeout(() => {
      try {
        renderPreview();
      } catch (err) {
        showStatus(err.message, true);
      }
    }, 400);
    return () => clearTimeout(timer);
  }, [renderPreview, showStatus]);

  useEffect(() => {
    try {
      loadPresets();
      loadPostList();

      // ì²« ë°©ë¬¸ ì‹œ ì˜ˆì œë¥¼ ê²Œì‹œë¬¼ë¡œ ì €ì¥í•˜ê³  ë¡œë“œ
      const isFirstVisit = !localStorage.getItem(FIRST_VISIT_KEY);
      const hasPosts = storage.listPosts().length > 0;
      if (isFirstVisit && !hasPosts) {
        const examplePost = storage.createPost({
          title: "ğŸ“¸ Insta Card Maker ì‚¬ìš©ë²•",
          markdown: EXAMPLE_MARKDOWN,
          preset: "reference",
          ratio: "4:5",
          backgroundImage: "",
        });
        setSavedPosts(storage.listPosts());
        setCurrentPostId(examplePost.id);
        setPostTitle(examplePost.title);
        setMarkdown(EXAMPLE_MARKDOWN);
        setPreset("reference");
        setRatio("4:5");
        localStorage.setItem(FIRST_VISIT_KEY, "1");
      }
    } catch (err) {
      showStatus(err.message, true);
    }
  }, [loadPostList, loadPresets, showStatus]);

  useEffect(() => {
    try {
      localStorage.setItem(SIDEBAR_STATE_KEY, sidebarCollapsed ? "1" : "0");
    } catch (_err) {
      // no-op
    }
  }, [sidebarCollapsed]);

  useEffect(() => {
    return () => {
      clearTimeout(statusTimerRef.current);
      clearPreviewUrls();
    };
  }, [clearPreviewUrls]);

  return (
    <div className="app-shell">
      <header className="topbar">
        <div className="topbar-left">
          <button
            type="button"
            className="icon-button"
            onClick={() => setSidebarCollapsed((prev) => !prev)}
            aria-expanded={!sidebarCollapsed}
            aria-label={sidebarCollapsed ? "ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—´ê¸°" : "ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‹«ê¸°"}
          >
            <Menu size={17} />
          </button>
          <button type="button" className="icon-button is-dark" aria-label="ìŠ¤íƒ€ì¼ ë©”ë‰´">
            <Sparkles size={15} />
          </button>
          <div className="brand-row">
            <p className="brand-title">Insta Card Maker</p>
            <p className="brand-meta">v2.0 Beta</p>
          </div>
        </div>

        <div className="topbar-center">
          <span className="toolbar-label">Styles</span>
          <div className="style-tabs">
            {styleTabs.map((tab) => (
              <button
                key={tab.value}
                type="button"
                className={cn("style-tab", tab.value === preset && "is-active")}
                onClick={() => setPreset(tab.value)}
              >
                {tab.label}
              </button>
            ))}
          </div>
        </div>

        <div className="topbar-right">
          <label className="ratio-select-wrap">
            <span className="sr-only">ë¹„ìœ¨ ì„ íƒ</span>
            <select value={ratio} onChange={(event) => setRatio(event.target.value)} className="ratio-select">
              {RATIO_OPTIONS.map((option) => (
                <option key={option} value={option}>
                  {option} Instagram Portrait
                </option>
              ))}
            </select>
          </label>
          <button
            type="button"
            className="primary-cta"
            disabled={exporting}
            onClick={() => {
              exportCards();
            }}
          >
            {exporting ? "Exporting..." : "Export"}
          </button>
        </div>
      </header>

      <main className={cn("workspace-grid", sidebarCollapsed && "is-sidebar-collapsed")}>
        <aside className={cn("library-pane", sidebarCollapsed && "is-collapsed")}>
          <div className="pane-header">
            <p>Library</p>
            <button type="button" className="link-btn" onClick={resetToNewPost}>
              <Plus size={14} />
            </button>
          </div>

          <div className="library-list">
            {!savedPosts.length && <p className="empty-hint">ì €ì¥ëœ ê²Œì‹œë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.</p>}
            {savedPosts.map((post) => {
              const active = post.id === currentPostId;
              return (
                <button
                  key={post.id}
                  type="button"
                  className={cn("library-item", active && "is-active")}
                  onClick={() => {
                    loadPost(post.id);
                  }}
                >
                  <p className="library-item-title">{post.title || "ì œëª© ì—†ìŒ"}</p>
                  <p className="library-item-meta">{formatRelative(post.updatedAt)}</p>
                </button>
              );
            })}
          </div>
        </aside>

        <section className="editor-pane">
          <div className="editor-title-row">
            <input
              className="editor-title-input"
              value={postTitle}
              onChange={(event) => setPostTitle(event.target.value)}
              placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
            />
            <div className="editor-tools" aria-hidden="true">
              <span>B</span>
              <span>I</span>
              <span>â†—</span>
              <span>â—«</span>
            </div>
          </div>

          <div className="editor-action-row">
            <button
              type="button"
              className="action-btn dark"
              onClick={() => {
                savePost();
              }}
            >
              <Save size={14} /> Save
            </button>
            <button type="button" className="action-btn" onClick={resetToNewPost}>
              <Plus size={14} /> New Slide
            </button>
            <button
              type="button"
              className="action-btn"
              disabled={!currentPostId}
              onClick={() => {
                deletePost();
              }}
            >
              <Trash2 size={14} /> Delete
            </button>
          </div>

          <textarea
            ref={markdownRef}
            className="editor-textarea"
            value={markdown}
            onChange={(event) => setMarkdown(event.target.value)}
            onPaste={handlePaste}
            placeholder=""
          />
          <p className="editor-hint">Use "---" to automatically split content into multiple slides.</p>
          <p className={cn("status-line", status.isError && "is-error")}>{status.message}</p>
        </section>

        <section className="preview-pane">
          <div className="pane-header preview-header">
            <p>Live Preview</p>
            <div className="preview-header-actions">
              <button type="button" className="preview-icon-btn" aria-label="ë¦¬ìŠ¤íŠ¸ ë³´ê¸°">
                <LayoutList size={13} />
              </button>
              <button type="button" className="preview-icon-btn" aria-label="ê·¸ë¦¬ë“œ ë³´ê¸°">
                <Grid2x2 size={13} />
              </button>
              <span className="preview-count">{previewFrames.length} Cards</span>
            </div>
          </div>

          {!markdown.trim() && <div className="preview-empty">ì™¼ìª½ ì—ë””í„°ì— ë‚´ìš©ì„ ì…ë ¥í•˜ë©´ ì¹´ë“œ ë¯¸ë¦¬ë³´ê¸°ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>}

          {markdown.trim() && (
            <div className="preview-scroll">
              {previewState.loading && <div className="preview-message">ë Œë”ë§ ì¤‘...</div>}
              {!previewState.loading && previewState.error && (
                <div className="preview-message is-error">{previewState.error}</div>
              )}
              {!previewState.loading && !previewState.error && !previewFrames.length && (
                <div className="preview-message">ì¹´ë“œê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</div>
              )}

              {!previewState.loading &&
                !previewState.error &&
                previewFrames.map((frame) => (
                  <article
                    key={frame.key}
                    className="preview-card-shell"
                    style={{ width: `${scaledW}px`, height: `${scaledH}px` }}
                  >
                    <iframe
                      title={`card-${frame.index}`}
                      src={frame.url}
                      width={previewState.width}
                      height={previewState.height}
                      style={{
                        border: "none",
                        display: "block",
                        transform: `scale(${previewScale})`,
                        transformOrigin: "top left",
                      }}
                    />
                    <span className="preview-index">
                      {String(frame.index).padStart(2, "0")} / {String(frame.total).padStart(2, "0")}
                    </span>
                  </article>
                ))}
            </div>
          )}
        </section>
      </main>

      <footer className="bottombar">
        <p>Auto-saved locally</p>
        <p>Markdown Enabled</p>
      </footer>
    </div>
  );
}
